NGINX:
    proxy: someone or something that acts on behalf of another.
    so in networking proxy server is a software that sits between a client
    and a destination server.
    it receives requests from the client and then forwards them to the real serve ,
    then sends the response back.

    Client  ‚Üí  Proxy  ‚Üí  Server
    Server  ‚Üí  Proxy  ‚Üí  Client

    - Forward Proxy Server:
        The client hires a proxy to talk to the internet on its behalf.
        The client knows about the proxy
        The destination server does not know the real client, it only sees the proxy‚Äôs IP
        Purpose: hide client, control what clients can access, bypass restrictions, caching.

        Client ‚Üí Forward Proxy ‚Üí Internet Server
    
    - Reverse Proxy:
        The server hires a proxy to deal with clients on its behalf.
        The client does not know it‚Äôs talking to a proxy ‚Äî it thinks it‚Äôs the real server.
        Purpose: hide servers, load balancing, SSL termination, caching, security.

        Client ‚Üí Reverse Proxy ‚Üí Backend Server(s)

    - Forward proxy: Client hides behind proxy ‚Üí server sees proxy.
    - Reverse proxy: Server hides behind proxy ‚Üí client doesn‚Äôt see proxy.

Understanding Web Servers:
    a web server is an application that allows you to request
    specific information from a remote computer ‚Äî and receive that information in a format you expect.

    so we need to enable communication between the user the the remote
    machine -> HTTP
    HTTP protocol: HTTP defines how a client (like a browser)
    asks for a resource, and how the server answers

    TCP is a stream-based protocol, not a message-based one.

üîÑ Program Lifecycle of ./webserv config_file
‚ö° Big Picture (Simplified)
    1. Parse config ‚Üí know what to serve.
    2. Open sockets ‚Üí wait for clients.
    3. Loop ‚Üí poll ‚Üí accept new clients ‚Üí read requests ‚Üí build responses ‚Üí send back.
    4. Keep alive or close depending on headers.
    5. Exit when stopped.

1. Program Start:
    - You run: ./webserv webserv.conf
    - Your main():
        1. Opens webserv.conf.
        2. Parses it (server blocks, ports, locations, error pages).
        3. Stores everything in C++ objects (ServerConfig, LocationConfig).
    üëâ At this point, your program knows:
        - Which ports to listen on.
        - Which files/folders to serve.
        - Which methods are allowed.
        - Which error pages to show.
-------------------------------------------------------------------

2. Setup Sockets:
    - For each server in config:
        - Create a TCP socket (socket()).
        - Bind it to the configured host:port.
        - Set it to listen (listen()).
    - Add all sockets to a poll() array (so you can watch multiple sockets at once).
    üëâ Now your program is ‚Äúlistening‚Äù for clients.

Webserve notes
    Phase 1: Config Parser
        - Implement parsing of webserv.conf.
        - Store config in C++ classes:
            ServerConfig (port, host, error pages‚Ä¶)
            LocationConfig (path, root, methods allowed‚Ä¶)
        - Make sure you can read a file like NGINX config and store values in memory.
            üëâ Test: run your program and print out config objects.


-----------------------------------------------------------------
Flow:
    1. User runs ./webserv my_config.conf.
    2. Your program opens my_config.conf.
    3. Parser reads lines, recognizes directives (listen, root, location).
    4. Stores them in memory (ServerConfig and LocationConfig objects).
    5. Later, when a client sends an HTTP request, your server looks at the parsed config to decide what to do.