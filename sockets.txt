# TCP:
    - connection-oriented protocol 
    - TCP allows a server and client pairs to exchange messages by using data segments packaged inside of data requests and responses
    - has built-in error checking and guarantees the delivery of all data
    - The protocol requires a connection. It is the responsibility of the client to make the initial request to start the connection
    # three_way handshake:
        1. TCP client (SYN) ----> TCP server
        2. TCP client <---- (ACK, SYN) TCP server
        3. TCP client (ACK) ----> TCP server
    
    1.SYN — Synchronize from the client:
        - The client wants to start a connection.
        - It sends a TCP packet with the SYN flag set
        - At this point, no data is sent yet, just the request to synchronize sequence numbers.

    2. SYN/ACK — Server acknowledges and synchronizes
        - The server receives the SYN packet.
        - It responds with a SYN/ACK packet:
            - ACK → acknowledges the client’s sequence number.
            - SYN → provides the server’s own sequence number.
    
    3. ACK — Client acknowledges server
        - The client receives the SYN/ACK
        - It sends back an ACK packet
        - Now both sides know the starting sequence numbers for each direction.

# intro to sockets:
sockets are an abstraction provided by os, enabling communication between different
processes, either on the same machine or over a network
they act as endpoint in a two-way communication channel, so when 2 machines or 2 applications
want to talk to each other each side of that communication will create a socket

 9.9.9.0:80
sockets operate primarily at the transport layer (layer 4)

types of sockets:
1. TCP sockets
2. UDP sockets

# lifecycle of socket:

1️⃣ Creation socket:
    - Purpose: Create a new socket in the kernel.
    - The OS allocates a socket structure in memory
    - This structure keeps track of state, IP, port, buffer queues, file descriptor, etc.
At this stage, the socket is not bound to an IP/port yet and cannot accept connections.

2️⃣ Bind:
    - bind(): Assigns the socket to a specific IP and port.
    - Without this, the OS wouldn’t know which port to listen on.

3️⃣ listen:
    - Marks the socket as passive, ready to accept connections.
    - Creates a pending connection queue in the kernel (size = backlog).
    - Now the socket doesn’t send/receive data directly; it only registers new clients.

4️⃣ Client creates a socket and connects:
    - Client side socket: Similar to the server, allocates a socket in the kernel.
    - connect():
        - Starts the 3-way handshake:
            1. SYN: Client says, “I want to connect. My starting sequence number is X.”
            2. SYN/ACK: Server replies, “I got your X. My sequence number is Y.”
            3. ACK: Client acknowledges server’s Y.
        Only after this handshake is complete is the connection established.

5️⃣ Kernel creates a new socket for the client (server side):
    - When a client connects:
        1. Kernel does not use the listening socket for data transfer.
        2. Kernel creates a new socket structure:
            - Stores the client’s IP and port
            - Tracks TCP state: sequence numbers, acknowledgment numbers, buffers.
        3. Returns a new file descriptor (client socket) to the server.
        Why: Each client must have its own independent connection. Otherwise, multiple clients would interfere with each other.

    Notes:
        - The listening socket you create with socket() and listen() is only for accepting new connections.
        - It never handles actual data transfer with clients.
        - It stays open so the server can continue accepting more clients.
        - When a client calls connect(), the kernel automatically creates a new socket structure for that client
6️⃣ Server accepts the client:
    - Pulls the first pending connection from the kernel’s queue.
    - Returns a new file descriptor for communication with this client
    - Original listening socket remains free to accept more clients.

7️⃣ Data transfer:
    - Both client and server can now send/receive data:
        - Server: uses the client-specific socket.
        - Client: uses its socket created in step 4.

8️⃣ Closing the connection:
    - Client and server close their respective sockets.
    - Kernel frees resources:
        - Memory buffers.
        - TCP state.
        - File descriptors.
    TCP performs a graceful shutdown using FIN/ACK to ensure all remaining data is delivered.

On the server side:
    - socket() → creates the listening socket.
    - listen() → tells the OS: “I’m ready to accept connections on this socket.”
    - accept() → creates a new socket for a specific client connection (the kernel does this and returns its file descriptor to you).

On the client side:
    - socket() → creates a socket for the client.
    - connect() → tells the OS: “please connect this socket to the server at IP:port.”
    If the server is listening,
    the kernel pairs this client socket with a new server socket (from accept()).

Client: socket() → connect()
Server: socket() → listen() → accept()